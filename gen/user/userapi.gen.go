// Package userapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package userapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	externalRef0 "github.com/I0Dzela/pisp-api/gen/common"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// CreateUserProfileFamiliarisationImageFileResp Set user profile image request body
type CreateUserProfileFamiliarisationImageFileResp struct {
	FileId *uint64 `json:"file_id"`
}

// Face Object representing face
type Face struct {
	CreatedAt time.Time `json:"createdAt"`
	FaceId    uint64    `json:"faceId"`

	// Fec FEC
	Fec          externalRef0.Fec `json:"fec"`
	FileId       uint64           `json:"fileId"`
	FilePath     string           `json:"filePath"`
	FileUrl      string           `json:"fileUrl"`
	FrameImageId uint64           `json:"frameImageId"`
	Id           uint64           `json:"id"`
}

// GetFamiliarisationImagesResponse Get user profile familiarisation images
type GetFamiliarisationImagesResponse struct {
	Count uint32   `json:"count"`
	Rows  []Sample `json:"rows"`
}

// GetUserResponse User response
type GetUserResponse struct {
	CreatedAt time.Time  `json:"createdAt"`
	DeletedAt *time.Time `json:"deletedAt"`
	Email     string     `json:"email"`
	FileUrl   string     `json:"fileUrl"`
	FirstName string     `json:"firstName"`
	Id        uint64     `json:"id"`
	LastName  string     `json:"lastName"`
	Roles     []string   `json:"roles"`
	UpdatedAt time.Time  `json:"updatedAt"`
}

// GetUsersResponse Object representing list of users and count
type GetUsersResponse struct {
	Count int    `json:"count"`
	Rows  []User `json:"rows"`
}

// Sample Object representing sample
type Sample struct {
	CreatedAt      time.Time  `json:"createdAt"`
	DeletedAt      *time.Time `json:"deletedAt"`
	Desc           []float32  `json:"desc"`
	DetectionScore float32    `json:"detectionScore"`

	// Face Object representing face
	Face             Face      `json:"face"`
	FaceIdScore      float32   `json:"faceIdScore"`
	FileId           uint64    `json:"fileId"`
	FileProcessingId uint64    `json:"fileProcessingId"`
	FileUrl          string    `json:"fileUrl"`
	Frame            uint64    `json:"frame"`
	FrameTime        uint64    `json:"frameTime"`
	Id               uint64    `json:"id"`
	UpdatedAt        time.Time `json:"updatedAt"`
	UserId           uint64    `json:"userId"`
	Valid            bool      `json:"valid"`
}

// UpdateFamiliarisationImageDto Update familiarisation image validity dto
type UpdateFamiliarisationImageDto struct {
	SampleId *uint64 `json:"sampleId"`
	Valid    *bool   `json:"valid"`
}

// UpdateFamiliarisationImagesResponse Update familiarisation images response
type UpdateFamiliarisationImagesResponse struct {
	Updated uint32 `json:"updated"`
}

// UpdateUserDto Update user dto
type UpdateUserDto struct {
	FirstName *string `json:"firstName"`
	LastName  *string `json:"lastName"`
}

// UpdateUserIdentityDto Update user identity DTO
type UpdateUserIdentityDto struct {
	Email     string `json:"email"`
	FirstName string `json:"firstName"`
	LastName  string `json:"lastName"`
	Sub       string `json:"sub"`
}

// User Object representing user
type User struct {
	CreatedAt time.Time  `json:"createdAt"`
	DeletedAt *time.Time `json:"deletedAt"`
	Email     string     `json:"email"`
	FileUrl   string     `json:"fileUrl"`
	FirstName string     `json:"firstName"`
	Id        uint64     `json:"id"`
	LastName  string     `json:"lastName"`
	UpdatedAt time.Time  `json:"updatedAt"`
}

// GetUsersParams defines parameters for GetUsers.
type GetUsersParams struct {
	// Page Page
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Search Search
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// GetFamiliarisationImagesParams defines parameters for GetFamiliarisationImages.
type GetFamiliarisationImagesParams struct {
	// Page Page
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// UpdateFamiliarisationImagesJSONBody defines parameters for UpdateFamiliarisationImages.
type UpdateFamiliarisationImagesJSONBody = []UpdateFamiliarisationImageDto

// SetProfileImageMultipartBody defines parameters for SetProfileImage.
type SetProfileImageMultipartBody struct {
	MyFile *openapi_types.File `json:"myFile,omitempty"`
}

// UpdateUserIdentityJSONRequestBody defines body for UpdateUserIdentity for application/json ContentType.
type UpdateUserIdentityJSONRequestBody = UpdateUserIdentityDto

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody = UpdateUserDto

// UpdateFamiliarisationImagesJSONRequestBody defines body for UpdateFamiliarisationImages for application/json ContentType.
type UpdateFamiliarisationImagesJSONRequestBody = UpdateFamiliarisationImagesJSONBody

// SetProfileImageMultipartRequestBody defines body for SetProfileImage for multipart/form-data ContentType.
type SetProfileImageMultipartRequestBody SetProfileImageMultipartBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get users
	// (GET /users)
	GetUsers(c *gin.Context, params GetUsersParams)
	// Update user identity by sub
	// (PUT /users/identity)
	UpdateUserIdentity(c *gin.Context)
	// Get users service version
	// (GET /users/version)
	GetVersion(c *gin.Context)
	// Get user by id
	// (GET /users/{id})
	GetUser(c *gin.Context, id uint64)
	// Update user by id
	// (PUT /users/{id})
	UpdateUser(c *gin.Context, id uint64)
	// Get profile familiarisation images
	// (GET /users/{id}/familiarisation-image)
	GetFamiliarisationImages(c *gin.Context, id uint64, params GetFamiliarisationImagesParams)
	// Update user familiarisation image
	// (PUT /users/{id}/familiarisation-image)
	UpdateFamiliarisationImages(c *gin.Context, id int)
	// Set profile image
	// (POST /users/{id}/profile-image)
	SetProfileImage(c *gin.Context, id uint64)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetUsers operation middleware
func (siw *ServerInterfaceWrapper) GetUsers(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUsersParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", c.Request.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter page: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", c.Request.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter pageSize: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", c.Request.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter search: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetUsers(c, params)
}

// UpdateUserIdentity operation middleware
func (siw *ServerInterfaceWrapper) UpdateUserIdentity(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateUserIdentity(c)
}

// GetVersion operation middleware
func (siw *ServerInterfaceWrapper) GetVersion(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetVersion(c)
}

// GetUser operation middleware
func (siw *ServerInterfaceWrapper) GetUser(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id uint64

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetUser(c, id)
}

// UpdateUser operation middleware
func (siw *ServerInterfaceWrapper) UpdateUser(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id uint64

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateUser(c, id)
}

// GetFamiliarisationImages operation middleware
func (siw *ServerInterfaceWrapper) GetFamiliarisationImages(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id uint64

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFamiliarisationImagesParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", c.Request.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter page: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", c.Request.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter pageSize: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetFamiliarisationImages(c, id, params)
}

// UpdateFamiliarisationImages operation middleware
func (siw *ServerInterfaceWrapper) UpdateFamiliarisationImages(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateFamiliarisationImages(c, id)
}

// SetProfileImage operation middleware
func (siw *ServerInterfaceWrapper) SetProfileImage(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id uint64

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.SetProfileImage(c, id)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/users", wrapper.GetUsers)
	router.PUT(options.BaseURL+"/users/identity", wrapper.UpdateUserIdentity)
	router.GET(options.BaseURL+"/users/version", wrapper.GetVersion)
	router.GET(options.BaseURL+"/users/:id", wrapper.GetUser)
	router.PUT(options.BaseURL+"/users/:id", wrapper.UpdateUser)
	router.GET(options.BaseURL+"/users/:id/familiarisation-image", wrapper.GetFamiliarisationImages)
	router.PUT(options.BaseURL+"/users/:id/familiarisation-image", wrapper.UpdateFamiliarisationImages)
	router.POST(options.BaseURL+"/users/:id/profile-image", wrapper.SetProfileImage)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"IagnAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(path.Dir(pathToFile), "./common.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
