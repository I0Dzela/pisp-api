// Package relationapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package relationapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	externalRef0 "github.com/I0Dzela/pisp-api/gen/common"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// CreateRelationDTO Create relation request body
type CreateRelationDTO struct {
	FileId           *uint64 `json:"file_id"`
	FileProcessingId *uint64 `json:"file_processing_id"`
	Frame            *int64  `json:"frame"`
	ImageId          *uint64 `json:"image_id"`
	Type             *uint32 `json:"type"`
	UserId           *uint64 `json:"user_id"`
	UserSubId        *uint64 `json:"user_sub_id"`
}

// Edge Request body containing list of relation types
type Edge = []uint64

// GetRelationsResponse Object representing list of relations
type GetRelationsResponse struct {
	Count int                  `json:"count"`
	Rows  []RelationFileSource `json:"rows"`
}

// GetVisualizationDataResponse Relations visualization data
type GetVisualizationDataResponse struct {
	// Edges Edges
	Edges []Edge `json:"edges"`

	// Nodes Nodes
	Nodes []Node `json:"nodes"`
}

// Node Node
type Node struct {
	Email     string `json:"email"`
	FirstName string `json:"firstName"`
	Group     uint32 `json:"group"`
	Id        string `json:"id"`
	LastName  string `json:"lastName"`
	Root      bool   `json:"root"`
	UserId    uint64 `json:"userId"`
}

// RelationFileSource Relation file source
type RelationFileSource struct {
	CreatedAt        time.Time `json:"createdAt"`
	FileId           uint64    `json:"fileId"`
	FileProcessingId uint64    `json:"fileProcessingId"`
	FileUrl          *string   `json:"fileUrl"`
	Filename         *string   `json:"filename"`

	// Frames Frames with relations
	Frames []uint64 `json:"frames"`
	Mime   *string  `json:"mime"`

	// RelationsCount Relations count
	RelationsCount uint64 `json:"relationsCount"`
}

// SetRelationsDTO Request body containing list of relation types
type SetRelationsDTO struct {
	Type *[]int `json:"type,omitempty"`
}

// GetRelationsParams defines parameters for GetRelations.
type GetRelationsParams struct {
	// Page Page
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Type Relations source type
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// UserId User id
	UserId *uint64 `form:"userId,omitempty" json:"userId,omitempty"`

	// SubUserId Sub user id
	SubUserId *uint64 `form:"subUserId,omitempty" json:"subUserId,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get relations
	// (GET /relations)
	GetRelations(c *gin.Context, params GetRelationsParams)
	// Get user relations visualization data full
	// (GET /relations/report/user/{userId})
	GetUserRelationsReportByUserId(c *gin.Context, userId uint64)
	// Get relations service version
	// (GET /relations/version)
	GetVersion(c *gin.Context)
	// Get graph visualization data
	// (GET /relations/visualization-data-full/user/{userId})
	GetGraphVisualizationData(c *gin.Context, userId uint64)
	// Get minimum spanning tree visualization data
	// (GET /relations/visualization-data-mst/user/{userId})
	GetMstVisualizationData(c *gin.Context, userId uint64)
	// Get shortest path visualization data
	// (GET /relations/visualization-data-sp/user/{userId}/sub-user/{subUserId})
	GetSpVisualizationData(c *gin.Context, userId uint64, subUserId uint64)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetRelations operation middleware
func (siw *ServerInterfaceWrapper) GetRelations(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRelationsParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", c.Request.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter page: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", c.Request.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter pageSize: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", c.Request.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter type: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "userId" -------------

	err = runtime.BindQueryParameter("form", true, false, "userId", c.Request.URL.Query(), &params.UserId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter userId: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "subUserId" -------------

	err = runtime.BindQueryParameter("form", true, false, "subUserId", c.Request.URL.Query(), &params.SubUserId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter subUserId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetRelations(c, params)
}

// GetUserRelationsReportByUserId operation middleware
func (siw *ServerInterfaceWrapper) GetUserRelationsReportByUserId(c *gin.Context) {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "userId", c.Param("userId"), &userId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter userId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetUserRelationsReportByUserId(c, userId)
}

// GetVersion operation middleware
func (siw *ServerInterfaceWrapper) GetVersion(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetVersion(c)
}

// GetGraphVisualizationData operation middleware
func (siw *ServerInterfaceWrapper) GetGraphVisualizationData(c *gin.Context) {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "userId", c.Param("userId"), &userId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter userId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetGraphVisualizationData(c, userId)
}

// GetMstVisualizationData operation middleware
func (siw *ServerInterfaceWrapper) GetMstVisualizationData(c *gin.Context) {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "userId", c.Param("userId"), &userId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter userId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetMstVisualizationData(c, userId)
}

// GetSpVisualizationData operation middleware
func (siw *ServerInterfaceWrapper) GetSpVisualizationData(c *gin.Context) {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "userId", c.Param("userId"), &userId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter userId: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "subUserId" -------------
	var subUserId uint64

	err = runtime.BindStyledParameterWithOptions("simple", "subUserId", c.Param("subUserId"), &subUserId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter subUserId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetSpVisualizationData(c, userId, subUserId)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/relations", wrapper.GetRelations)
	router.GET(options.BaseURL+"/relations/report/user/:userId", wrapper.GetUserRelationsReportByUserId)
	router.GET(options.BaseURL+"/relations/version", wrapper.GetVersion)
	router.GET(options.BaseURL+"/relations/visualization-data-full/user/:userId", wrapper.GetGraphVisualizationData)
	router.GET(options.BaseURL+"/relations/visualization-data-mst/user/:userId", wrapper.GetMstVisualizationData)
	router.GET(options.BaseURL+"/relations/visualization-data-sp/user/:userId/sub-user/:subUserId", wrapper.GetSpVisualizationData)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xX32/bNhD+VwRuj3LkpEO36a3rmmAb1hZx0j0ERkFLZ5mFRLJHKq0b6H8fSEqyLFGO",
	"3HhAgfVNpo/H4/d994MPJBGFFBy4ViR+ICrZQEHt50sEquEacqqZ4L/fvDGLKagEmTQrJK5NAqxtAoSP",
	"JSgdrES6JSGRKCSgZmD9rVkO71lqPuEzLWQOJD6fh2QtsKCaxKRkXD//iYREbyWQmDCuIQMkIfk8EwXT",
	"UEi9JfGa5gqq0PmTKBJQivHspK6RFjDu7ThnrKDZSS/urA45e3Yx2VmpAE8ZnPWnytXpfLY3JmL1ARJN",
	"qpC8SjMYyvG6I78gEVxTxhnPgpwpHYj1TqfGnyIhMSc5bT4WWRUSI26GkJL4rt64bM0oIt0aoyvQTcao",
	"a1BScOUJ9I29SIAgERRw7QtSDRIoESXX5mMaEyg+2W3tJX9EWJOY/BDtUj6q8z1qgr5kOSxEiQmQqne7",
	"MXK6uNgzwzrSpYe4K9DvmCppzr64skI1HcephTK4724KUqrpAB5IM/ex7+OVXQ6nwWB1VQ1p5SL1+X5t",
	"lyf6NsZD3z0Aee3RXcaHoHXjjWSISEFZ3hGM0sh4Nl5PUenXdeGbtCNDUcpB+viKjymD6WS/OT0yEBSi",
	"mxgrIXKg/FCJ+iOdlvb9vE9JF6hOqGGNdoNKe0wdnY9KT9KNpkBg2l2gnNWgMtg+nL7QfsQyMasXNSvg",
	"7IbZeNv1GSukQLuXW9RJbSGp3tSbTLijXXgimAc8vG3b+NN93eIxms+BH6M0Oxl4KsGlXQ8+Mb3Zq+BH",
	"dZh+1SnYMTnQnPqyaRNjtdRV5ye0425G1Px7aGzBGsQWdgTry4tFp4l6586jG/1+ujQDVEvOY1T4RpBE",
	"FIXg701DA1RM8PE2VhsE2FgMAjqGaFNXJhvfu6Mn2ve4bTbXZ4YuziFjVUgUJCUyvV2YZucutQKKgC9K",
	"U0OaX5eN5P7854aE7rVhK7b9d6fAjdaSVMYx42vhINJmjOzIeAF4b/e0dyTnZxeGGiGBU8lITJ6dzc/O",
	"60pmg4p2yRk/kAxsohgq7KIpPnsjnN1qVKwBFYnv+sy+pZkt/c2UOzcBk5h8LAHNxFTXU+nM3CTgE1wV",
	"+jwHin2Z6n7hTI85Ygelays2W4j/iPqvgftaTR7vtwowsP3S569tjjuPU5px/5BFuQrKgwepcnX7VWct",
	"TS64fLVauZjP3RDONbj6SqXMWWIhjD4ol2S7Iw6Ngt5XgpV7753w115yWQF20+puacJUZVFQ3DrpdrqP",
	"2brTe4Rgunxk4IoeHP7VoSQwsHWiNJt/27ZYHkyLHvd2jhhSvys1Gks4DT1Px8/KCQ88PIJ1med9cDt1",
	"dgzPd201/c90Nd6TDojLr55AAd6zBILmZv0Ld3GZGVxmBpfp8rpCKjeDt+C3q6xTJf748/dEBSAzwPoe",
	"zI8zWKgj6sPfSn+n7/T0FYyzoiwCJSm3Q61GgK+jU8l9NiNVrmZupW2LByleyG+R4SlTwP653SHgfy0u",
	"tRGozcvJ4OMXlXVpJmvHbmle03YeV3EUsblkSp4looh/ns9/jYghY9/EGuQioXn8fD7/JSLVsvo3AAD/",
	"/3z4UiZmGAAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(path.Dir(pathToFile), "./common.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
