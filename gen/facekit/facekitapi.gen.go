// Package facekitapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package facekitapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	externalRef0 "github.com/I0Dzela/pisp-api/gen/common"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for GetFileProcessingListParamsMime.
const (
	Imagejpeg GetFileProcessingListParamsMime = "image/jpeg"
	Videomp4  GetFileProcessingListParamsMime = "video/mp4"
)

// Defines values for GetFileProcessingListParamsType.
const (
	UPLOAD GetFileProcessingListParamsType = "UPLOAD"
	URL    GetFileProcessingListParamsType = "URL"
)

// Defines values for GetFileProcessingListParamsStatus.
const (
	ERROR      GetFileProcessingListParamsStatus = "ERROR"
	PROCESSED  GetFileProcessingListParamsStatus = "PROCESSED"
	PROCESSING GetFileProcessingListParamsStatus = "PROCESSING"
)

// CreateFileProcessingDownloadRequest Request body containing Youtube URL
type CreateFileProcessingDownloadRequest struct {
	Url string `json:"url"`
}

// CreateFileProcessingDownloadResponse File processing download response
type CreateFileProcessingDownloadResponse struct {
	Attempt      uint64     `json:"attempt"`
	CreatedAt    time.Time  `json:"createdAt"`
	CreatedBy    uint64     `json:"createdBy"`
	CurrentFrame uint64     `json:"currentFrame"`
	DeletedAt    *time.Time `json:"deletedAt"`
	Duration     *float64   `json:"duration"`
	Error        *string    `json:"error"`
	FileId       uint64     `json:"fileId"`
	FilePath     string     `json:"filePath"`
	Filename     *string    `json:"filename"`
	FrameRate    *float64   `json:"frameRate"`
	FrameStep    *uint64    `json:"frameStep"`
	Id           uint64     `json:"id"`
	Mime         string     `json:"mime"`
	NbFrames     *uint64    `json:"nbFrames"`
	Status       string     `json:"status"`
	Type         string     `json:"type"`
	UpdatedAt    time.Time  `json:"updatedAt"`
}

// CreateFileProcessingResponse Object representing successful file processing create
type CreateFileProcessingResponse struct {
	Error    *string `json:"error"`
	Filename string  `json:"filename"`
	Id       uint64  `json:"id"`
}

// CreatedByUser Request body containing file id and error
type CreatedByUser struct {
	Email     string `json:"email"`
	FirstName string `json:"firstName"`
	Id        uint64 `json:"id"`
	LastName  string `json:"lastName"`
}

// Face Object representing frame image
type Face struct {
	CreatedAt *time.Time `json:"createdAt"`
	DeletedAt *time.Time `json:"deletedAt"`
	FaceId    *uint64    `json:"faceId"`

	// Fec FEC
	Fec            *externalRef0.Fec `json:"fec,omitempty"`
	FileId         *uint64           `json:"fileId"`
	FilePath       *string           `json:"filePath"`
	FileUrl        *string           `json:"fileUrl"`
	FrameImageId   *uint64           `json:"frameImageId"`
	Id             *uint64           `json:"id"`
	RectanglePMaxX *int              `json:"rectanglePMaxX"`
	RectanglePMaxY *int              `json:"rectanglePMaxY"`
	RectanglePMinX *int              `json:"rectanglePMinX"`
	RectanglePMinY *int              `json:"rectanglePMinY"`
	UpdatedAt      *time.Time        `json:"updatedAt"`

	// User FaceId user
	User *FaceIdUser `json:"user,omitempty"`
}

// FaceIdUser FaceId user
type FaceIdUser struct {
	Email     *string `json:"email"`
	FileUrl   *string `json:"fileUrl"`
	FirstName *string `json:"firstName"`
	Id        *uint64 `json:"id"`
	LastName  *string `json:"lastName"`
}

// FileMetadata Object representing file metadata
type FileMetadata struct {
	CreatedAt *time.Time       `json:"created_at"`
	Data      *json.RawMessage `json:"data"`
	DeletedAt *time.Time       `json:"deleted_at"`

	// File Get file by processing id response
	File      *GetFileResponse `json:"file,omitempty"`
	FileId    *int64           `json:"file_id"`
	Id        *int64           `json:"id"`
	UpdatedAt *time.Time       `json:"updated_at"`
}

// FileProcessingListItem Object representing file processing
type FileProcessingListItem struct {
	Attempt   uint64     `json:"attempt"`
	CreatedAt time.Time  `json:"createdAt"`
	CreatedBy uint64     `json:"createdBy"`
	DeletedAt *time.Time `json:"deletedAt"`
	Error     *string    `json:"error"`
	FileId    uint64     `json:"fileId"`
	FileUrl   string     `json:"fileUrl"`
	Filename  *string    `json:"filename"`
	FrameStep *uint64    `json:"frameStep"`
	Id        uint64     `json:"id"`
	Mime      *string    `json:"mime"`
	Status    string     `json:"status"`
	Type      string     `json:"type"`
	UpdatedAt time.Time  `json:"updatedAt"`

	// User Request body containing file id and error
	User CreatedByUser `json:"user"`
}

// Frame Object representing frame image
type Frame struct {
	CreatedAt        *time.Time `json:"createdAt"`
	DeletedAt        *time.Time `json:"deletedAt"`
	Faces            *[]Face    `json:"faces"`
	FileId           *uint64    `json:"fileId"`
	FilePath         *string    `json:"filePath"`
	FileProcessingId *uint64    `json:"fileProcessingId"`
	FileUrl          *string    `json:"fileUrl"`
	Frame            *uint64    `json:"frame"`
	FrameTime        *uint64    `json:"frameTime"`
	Id               *uint64    `json:"id"`
	UpdatedAt        *time.Time `json:"updatedAt"`
}

// GetFileProcessingListResponse Object representing list of file processings and count
type GetFileProcessingListResponse struct {
	Count int                      `json:"count"`
	Rows  []FileProcessingListItem `json:"rows"`
}

// GetFileProcessingResponse Object representing file processing
type GetFileProcessingResponse struct {
	Attempt      uint64     `json:"attempt"`
	CreatedAt    time.Time  `json:"createdAt"`
	CreatedBy    uint64     `json:"createdBy"`
	CurrentFrame uint64     `json:"currentFrame"`
	DeletedAt    *time.Time `json:"deletedAt"`
	Duration     float64    `json:"duration"`
	Error        *string    `json:"error"`
	FileId       uint64     `json:"fileId"`
	FilePath     string     `json:"filePath"`
	FileUrl      string     `json:"fileUrl"`
	Filename     *string    `json:"filename"`
	FrameRate    float64    `json:"frameRate"`
	FrameStep    *uint64    `json:"frameStep"`
	Id           uint64     `json:"id"`
	Mime         string     `json:"mime"`
	NbFrames     uint64     `json:"nbFrames"`
	Status       string     `json:"status"`
	Type         string     `json:"type"`
	UpdatedAt    time.Time  `json:"updatedAt"`

	// User Request body containing file id and error
	User CreatedByUser `json:"user"`
}

// GetFileResponse Get file by processing id response
type GetFileResponse struct {
	CreatedAt time.Time  `json:"created_at"`
	DeletedAt *time.Time `json:"deleted_at"`
	Filename  *string    `json:"filename"`
	Id        uint64     `json:"id"`
	Mime      string     `json:"mime"`
	UpdatedAt time.Time  `json:"updated_at"`
}

// GetFramesResponse Get frames response
type GetFramesResponse struct {
	Count *int     `json:"count"`
	Rows  *[]Frame `json:"rows"`
}

// GetStatusResponse Object representing file processing status
type GetStatusResponse struct {
	Attempt      uint64     `json:"attempt"`
	CreatedAt    time.Time  `json:"createdAt"`
	CreatedBy    uint64     `json:"createdBy"`
	CurrentFrame uint64     `json:"currentFrame"`
	DeletedAt    *time.Time `json:"deletedAt"`
	Error        *string    `json:"error"`
	FileId       uint64     `json:"fileId"`
	FilePath     string     `json:"filePath"`
	Filename     *string    `json:"filename"`
	FrameRate    float64    `json:"frameRate"`
	FrameStep    *uint64    `json:"frameStep"`
	Id           uint64     `json:"id"`
	Mime         string     `json:"mime"`
	NbFrames     uint64     `json:"nbFrames"`
	Status       string     `json:"status"`
	Type         string     `json:"type"`
	UpdatedAt    time.Time  `json:"updatedAt"`
}

// GetFileProcessingListParams defines parameters for GetFileProcessingList.
type GetFileProcessingListParams struct {
	// Page Page
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// UsedId User id
	UsedId *uint64 `form:"usedId,omitempty" json:"usedId,omitempty"`

	// Mime File processing mime
	Mime *GetFileProcessingListParamsMime `form:"mime,omitempty" json:"mime,omitempty"`

	// Type File processing type
	Type *GetFileProcessingListParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Status File processing status
	Status *GetFileProcessingListParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// From File processing status
	From *openapi_types.Date `form:"from,omitempty" json:"from,omitempty"`

	// To File processing status
	To *openapi_types.Date `form:"to,omitempty" json:"to,omitempty"`

	// Search Filter by filename
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// FileId File id
	FileId *uint64 `form:"fileId,omitempty" json:"fileId,omitempty"`
}

// GetFileProcessingListParamsMime defines parameters for GetFileProcessingList.
type GetFileProcessingListParamsMime string

// GetFileProcessingListParamsType defines parameters for GetFileProcessingList.
type GetFileProcessingListParamsType string

// GetFileProcessingListParamsStatus defines parameters for GetFileProcessingList.
type GetFileProcessingListParamsStatus string

// CreateFileProcessingMultipartBody defines parameters for CreateFileProcessing.
type CreateFileProcessingMultipartBody struct {
	Filename *[]openapi_types.File `json:"filename,omitempty"`
}

// CreateFileProcessingParams defines parameters for CreateFileProcessing.
type CreateFileProcessingParams struct {
	// FrameStep Frame step
	FrameStep *uint64 `form:"frameStep,omitempty" json:"frameStep,omitempty"`
}

// CreateFileProcessingDownloadParams defines parameters for CreateFileProcessingDownload.
type CreateFileProcessingDownloadParams struct {
	// FrameStep Frame step
	FrameStep *int `form:"frameStep,omitempty" json:"frameStep,omitempty"`
}

// CreateFileProcessingByFileIdParams defines parameters for CreateFileProcessingByFileId.
type CreateFileProcessingByFileIdParams struct {
	// FrameStep Frame step
	FrameStep *uint64 `form:"frameStep,omitempty" json:"frameStep,omitempty"`
}

// GetFramesParams defines parameters for GetFrames.
type GetFramesParams struct {
	// Frames Frames to filter
	Frames []uint64 `form:"frames" json:"frames"`
}

// CreateFileProcessingMultipartRequestBody defines body for CreateFileProcessing for multipart/form-data ContentType.
type CreateFileProcessingMultipartRequestBody CreateFileProcessingMultipartBody

// CreateFileProcessingDownloadJSONRequestBody defines body for CreateFileProcessingDownload for application/json ContentType.
type CreateFileProcessingDownloadJSONRequestBody = CreateFileProcessingDownloadRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get file processing list
	// (GET /facekit/file-processing)
	GetFileProcessingList(c *gin.Context, params GetFileProcessingListParams)
	// Create file processing
	// (POST /facekit/file-processing)
	CreateFileProcessing(c *gin.Context, params CreateFileProcessingParams)
	// Create file processing download
	// (POST /facekit/file-processing/download)
	CreateFileProcessingDownload(c *gin.Context, params CreateFileProcessingDownloadParams)
	// Create file processing for existing file
	// (POST /facekit/file-processing/file/{id})
	CreateFileProcessingByFileId(c *gin.Context, id uint64, params CreateFileProcessingByFileIdParams)
	// Get file processing by id
	// (GET /facekit/file-processing/{id})
	GetFileProcessing(c *gin.Context, id uint64)
	// Get file by file processing id
	// (GET /facekit/file-processing/{id}/file)
	GetFile(c *gin.Context, id uint64)
	// Get frames
	// (GET /facekit/file-processing/{id}/frames)
	GetFrames(c *gin.Context, id uint64, params GetFramesParams)
	// Get file processing status
	// (GET /facekit/file-processing/{id}/status)
	GetStatus(c *gin.Context, id uint64)
	// Get facekit server version
	// (GET /facekit/version)
	GetVersion(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetFileProcessingList operation middleware
func (siw *ServerInterfaceWrapper) GetFileProcessingList(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFileProcessingListParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", c.Request.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter page: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", c.Request.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter pageSize: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "usedId" -------------

	err = runtime.BindQueryParameter("form", true, false, "usedId", c.Request.URL.Query(), &params.UsedId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter usedId: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "mime" -------------

	err = runtime.BindQueryParameter("form", true, false, "mime", c.Request.URL.Query(), &params.Mime)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter mime: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", c.Request.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter type: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", c.Request.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter status: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", c.Request.URL.Query(), &params.From)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter from: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", c.Request.URL.Query(), &params.To)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter to: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", c.Request.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter search: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "fileId" -------------

	err = runtime.BindQueryParameter("form", true, false, "fileId", c.Request.URL.Query(), &params.FileId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter fileId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetFileProcessingList(c, params)
}

// CreateFileProcessing operation middleware
func (siw *ServerInterfaceWrapper) CreateFileProcessing(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateFileProcessingParams

	// ------------- Optional query parameter "frameStep" -------------

	err = runtime.BindQueryParameter("form", true, false, "frameStep", c.Request.URL.Query(), &params.FrameStep)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter frameStep: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateFileProcessing(c, params)
}

// CreateFileProcessingDownload operation middleware
func (siw *ServerInterfaceWrapper) CreateFileProcessingDownload(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateFileProcessingDownloadParams

	// ------------- Optional query parameter "frameStep" -------------

	err = runtime.BindQueryParameter("form", true, false, "frameStep", c.Request.URL.Query(), &params.FrameStep)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter frameStep: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateFileProcessingDownload(c, params)
}

// CreateFileProcessingByFileId operation middleware
func (siw *ServerInterfaceWrapper) CreateFileProcessingByFileId(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id uint64

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateFileProcessingByFileIdParams

	// ------------- Optional query parameter "frameStep" -------------

	err = runtime.BindQueryParameter("form", true, false, "frameStep", c.Request.URL.Query(), &params.FrameStep)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter frameStep: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateFileProcessingByFileId(c, id, params)
}

// GetFileProcessing operation middleware
func (siw *ServerInterfaceWrapper) GetFileProcessing(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id uint64

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetFileProcessing(c, id)
}

// GetFile operation middleware
func (siw *ServerInterfaceWrapper) GetFile(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id uint64

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetFile(c, id)
}

// GetFrames operation middleware
func (siw *ServerInterfaceWrapper) GetFrames(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id uint64

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFramesParams

	// ------------- Required query parameter "frames" -------------

	if paramValue := c.Query("frames"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument frames is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "frames", c.Request.URL.Query(), &params.Frames)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter frames: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetFrames(c, id, params)
}

// GetStatus operation middleware
func (siw *ServerInterfaceWrapper) GetStatus(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id uint64

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetStatus(c, id)
}

// GetVersion operation middleware
func (siw *ServerInterfaceWrapper) GetVersion(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetVersion(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/facekit/file-processing", wrapper.GetFileProcessingList)
	router.POST(options.BaseURL+"/facekit/file-processing", wrapper.CreateFileProcessing)
	router.POST(options.BaseURL+"/facekit/file-processing/download", wrapper.CreateFileProcessingDownload)
	router.POST(options.BaseURL+"/facekit/file-processing/file/:id", wrapper.CreateFileProcessingByFileId)
	router.GET(options.BaseURL+"/facekit/file-processing/:id", wrapper.GetFileProcessing)
	router.GET(options.BaseURL+"/facekit/file-processing/:id/file", wrapper.GetFile)
	router.GET(options.BaseURL+"/facekit/file-processing/:id/frames", wrapper.GetFrames)
	router.GET(options.BaseURL+"/facekit/file-processing/:id/status", wrapper.GetStatus)
	router.GET(options.BaseURL+"/facekit/version", wrapper.GetVersion)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(path.Dir(pathToFile), "./common.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
